---
title: Uva >> The 3n + 1 problem [#18694054]
date: 2017-01-29 10:54:50
categories:
- 笔记
- Algorithm
tags:
- Uva
---
路径：Uva.onlinejudge.org >> Root :: Problem Set Volumes (100...1999) :: Volume 1 (100-199)

## 我的代码

```c
#include <stdio.h>
int main()
{
    unsigned long start = 0, end = 0, _start = 0, _end = 0, count = 0, max = 0, i = 0, num = 0;

    while (scanf("%ld%ld", &start, &end) != EOF) {

        _start = start;

        _end = end;

        max = 1;

        if(start > end) {
            int tmp;

            tmp = start;

            start = end;

            end = tmp;
        }

        for(i = start; i <= end; i++) {
            num = i;

            count = 1;

            while(num != 1) {
                if(num % 2 != 0) {
                    num = num * 3 + 1;
                } else {
                    num = num / 2;
                }

                count++;
            }

            if(count > max) {
                max = count;
            }
        }

        printf("%ld %ld %ld\n", _start, _end, max);
    }

    return 0;
}
```

## 参考别人的代码
```c
/*
*url https://quickgrid.wordpress.com/2015/02/06/uva-problem-100-the-3n-1-problem-solution/
*/
#include <stdio.h>
#define SIZE 1000002

long int table[SIZE];

long int fn(long int n)
{
    if(n < SIZE && table[n] > 0) {
        return table[n];
    }

    if(n & 1) {//odd
        if(n < SIZE) {
            table[n] = 2 + fn((3 * n + 1) >> 1);

            return table[n];
        }

        return 2 + fn((3 * n + 1) >> 1);
    } else {
        if(n < SIZE) {
            table[n] = 1 + fn(n >> 1);

            return table[n];
        }

        return 1 + fn(n >> 1);
    }
}

int main()
{
    long int start = 0, end = 0, _start = 0, _end = 0, n = 0, max = 1, count = 1, i = 0;

    for(i = 0; i <= SIZE; i++) {
        table[i] = 0;
    }

    table[1] = 1;

    while (scanf("%ld%ld", &start, &end) != EOF) {

        _start = start;

        _end = end;

        if(start > end) {
            int tmp;

            tmp = start;

            start = end;

            end = tmp;
        }

        max = 1;

        for (n = start; n <= end; n++) {
            count = fn(n);

            if(count > max) {
                max = count;
            }
        }

        printf("%ld %ld %ld\n", _start, _end, max);
    }

    return 0;
}
```

>注意事项：数据长度unsigned 或者 long；每次读入的两个数的大小，例如读入<code>a b</code>,如果a > b,需要交换a b，但是输出的时候要按照读入的顺序输出.
<p>参考代码使用了与运算判奇偶，奇数与1做与运算，奇数二进制最低位为1，偶数二进制最低位为0，所以偶数与1做与运算为0，奇数与1做与运算大于等于1.<>
使用位移运算，将一个数向右移一位相当于 mod 2.
使用table[]保存所有已经求过的最大循环次数.

## 参考
- [参考代码原链接](https://quickgrid.wordpress.com/2015/02/06/uva-problem-100-the-3n-1-problem-solution/)
- [Memoization](https://en.wikipedia.org/wiki/Memoization)
- [Lookup Table](https://en.wikipedia.org/wiki/Lookup_table)
- [Recursion](https://en.wikipedia.org/wiki/Recursion)
- [Dynamic Programming](https://en.wikipedia.org/wiki/Dynamic_programming)
- [Bitwise Operations](https://www.codeproject.com/articles/2247/an-introduction-to-bitwise-operators)
- [Collatz Conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture)
- [Algorithmist Solution](http://www.algorithmist.com/index.php/UVa_100)
